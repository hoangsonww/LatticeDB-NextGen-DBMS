# LatticeDB - Modern Production-Ready Relational Database Management System üöÄ

*A feature-complete, high-performance RDBMS with native AI/ML support, time-travel queries, streaming statistics, built-in GUI, and enterprise security.*

> [!IMPORTANT]
> **Mission**: Deliver a modern database that seamlessly integrates traditional RDBMS capabilities with cutting-edge features like vector search, temporal queries, adaptive compression, and comprehensive security - all in a single, cohesive system.

<p align="center">
  <img src="docs/logo.png" alt="LatticeDB Logo" width="50%"/>
</p>

[![C++17](https://img.shields.io/badge/C%2B%2B-17-00599C?logo=c%2B%2B&logoColor=white&style=for-the-badge)](https://isocpp.org/)
[![Bash](https://img.shields.io/badge/Bash-Scripts-4EAA25?logo=gnubash&logoColor=white&style=for-the-badge)](https://www.gnu.org/software/bash/)
[![Python](https://img.shields.io/badge/Python-Helper%20Tools-3776AB?logo=python&logoColor=white&style=for-the-badge)](https://www.python.org/)
[![CMake](https://img.shields.io/badge/CMake-3.15%2B-064F8C?logo=cmake&logoColor=white&style=for-the-badge)](https://cmake.org/)
[![Ninja](https://img.shields.io/badge/Ninja-Build-000000?logo=ninja&logoColor=white&style=for-the-badge)](https://ninja-build.org/)
[![GCC](https://img.shields.io/badge/GCC-Compiler-4EAA25?logo=gnu&logoColor=white&style=for-the-badge)](https://gcc.gnu.org/)
[![Clang/LLVM](https://img.shields.io/badge/Clang-LLVM-262D3A?logo=llvm&logoColor=white&style=for-the-badge)](https://llvm.org/)
[![GitHub Actions](https://img.shields.io/badge/GitHub%20Actions-CI-2088FF?logo=githubactions&logoColor=white&style=for-the-badge)](https://github.com/features/actions)
[![CodeQL](https://img.shields.io/badge/CodeQL-Security%20Scan-2F67A1?logo=github&logoColor=white&style=for-the-badge)](https://codeql.github.com/)
[![Dependabot](https://img.shields.io/badge/Dependabot-Updates-025E8C?logo=dependabot&logoColor=white&style=for-the-badge)](https://github.com/dependabot)
[![AddressSanitizer](https://img.shields.io/badge/Sanitizer-ASan-5E4B8B?logo=llvm&logoColor=white&style=for-the-badge)](https://clang.llvm.org/docs/AddressSanitizer.html)
[![UBSan](https://img.shields.io/badge/Sanitizer-UBSan-5E4B8B?logo=llvm&logoColor=white&style=for-the-badge)](https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html)
[![clang-format](https://img.shields.io/badge/clang--format-Style-262D3A?logo=llvm&logoColor=white&style=for-the-badge)](https://clang.llvm.org/docs/ClangFormat.html)
[![cppcheck](https://img.shields.io/badge/cppcheck-Static%20Analysis-8892BF?logo=cpp&logoColor=white&style=for-the-badge)](http://cppcheck.sourceforge.net/)
[![Docker](https://img.shields.io/badge/Docker-Container-2496ED?logo=docker&logoColor=white&style=for-the-badge)](https://www.docker.com/)
[![Ubuntu](https://img.shields.io/badge/Ubuntu-24.04-E95420?logo=ubuntu&logoColor=white&style=for-the-badge)](https://ubuntu.com/)
[![macOS](https://img.shields.io/badge/macOS-Supported-000000?logo=apple&logoColor=white&style=for-the-badge)](https://www.apple.com/macos/)
[![WSL2](https://img.shields.io/badge/WSL2-Dev-0078D6?logo=windows&logoColor=white&style=for-the-badge)](https://learn.microsoft.com/windows/wsl/)
[![Mermaid](https://img.shields.io/badge/Mermaid-Diagrams-1B6AC6?logo=mermaid&logoColor=white&style=for-the-badge)](https://mermaid.js.org/)
[![EditorConfig](https://img.shields.io/badge/EditorConfig-Consistent%20Style-000000?logo=editorconfig&logoColor=white&style=for-the-badge)](https://editorconfig.org/)
[![Vite](https://img.shields.io/badge/Vite-Bundler-646CFF?logo=vite&logoColor=white&style=for-the-badge)](https://vitejs.dev/)
[![React Query](https://img.shields.io/badge/React%20Query-Data%20Fetching-FF4154?logo=reactquery&logoColor=white&style=for-the-badge)](https://tanstack.com/query/latest)
[![Vercel](https://img.shields.io/badge/Vercel-Hosting-000000?logo=vercel&logoColor=white&style=for-the-badge)](https://vercel.com/)
[![React](https://img.shields.io/badge/React-GUI-61DAFB?logo=react&logoColor=black&style=for-the-badge)](https://react.dev/)
[![TypeScript](https://img.shields.io/badge/TypeScript-Frontend-3178C6?logo=typescript&logoColor=white&style=for-the-badge)](https://www.typescriptlang.org/)
[![TailwindCSS](https://img.shields.io/badge/TailwindCSS-Styling-06B6D4?logo=tailwindcss&logoColor=white&style=for-the-badge)](https://tailwindcss.com/)
[![Travis CI](https://img.shields.io/badge/Travis%20CI-CI/CD-3EAAAF?logo=travisci&logoColor=white&style=for-the-badge)](https://travis-ci.com/)
[![Jenkins](https://img.shields.io/badge/Jenkins-CI/CD-D24939?logo=jenkins&logoColor=white&style=for-the-badge)](https://www.jenkins.io/)
[![Terraform](https://img.shields.io/badge/Terraform-IaC-623CE4?logo=terraform&logoColor=white&style=for-the-badge)](https://www.terraform.io/)
[![AWS](https://img.shields.io/badge/AWS-Deployment-232F3E?logo=amazonaws&logoColor=white&style=for-the-badge)](https://aws.amazon.com/)
[![Azure](https://img.shields.io/badge/Azure-Deployment-0089D6?logo=microsoftazure&logoColor=white&style=for-the-badge)](https://azure.microsoft.com/)
[![GCP](https://img.shields.io/badge/GCP-Deployment-4285F4?logo=googlecloud&logoColor=white&style=for-the-badge)](https://cloud.google.com/)
[![Nomad](https://img.shields.io/badge/Nomad-Orchestration-4A4A4A?logo=hashicorp&logoColor=white&style=for-the-badge)](https://www.nomadproject.io/)
[![Consul](https://img.shields.io/badge/Consul-Service%20Mesh-4A4A4A?logo=hashicorp&logoColor=white&style=for-the-badge)](https://www.consul.io/)
[![Vault](https://img.shields.io/badge/Vault-Secrets%20Management-4A4A4A?logo=hashicorp&logoColor=white&style=for-the-badge)](https://www.vaultproject.io/)
[![Prometheus](https://img.shields.io/badge/Prometheus-Monitoring-E6522C?logo=prometheus&logoColor=white&style=for-the-badge)](https://prometheus.io/)
[![Grafana](https://img.shields.io/badge/Grafana-Dashboard-F46800?logo=grafana&logoColor=white&style=for-the-badge)](https://grafana.com/)
[![Jaeger](https://img.shields.io/badge/Jaeger-Tracing-EC4815?logo=jaeger&logoColor=white&style=for-the-badge)](https://www.jaegertracing.io/)
[![OpenTelemetry](https://img.shields.io/badge/OpenTelemetry-Observability-4EAA25?logo=opentelemetry&logoColor=white&style=for-the-badge)](https://opentelemetry.io/)
[![GitHub Actions](https://img.shields.io/badge/GitHub%20Actions-CI/CD-2088FF?logo=githubactions&logoColor=white&style=for-the-badge)](https://docs.github.com/en/actions)
[![License: MIT](https://img.shields.io/badge/License-MIT-3DA639?logo=open-source-initiative&logoColor=white&style=for-the-badge)](LICENSE)

## Table of Contents

- [Why LatticeDB](#why-latticedb)
- [Feature Matrix & How It‚Äôs Different](#feature-matrix--how-its-different)
- [Architecture Overview](#architecture-overview)
- [Quick Start](#quick-start)
  - [Prerequisites](#prerequisites)
  - [Build from Source](#build-from-source)
  - [Hello World - Working Examples](#hello-world---working-examples)
  - [DevContainer (VS Code)](#devcontainer-vs-code)
  - [Command-Line Interface (CLI)](#command-line-interface-cli)
- [Start with GUI](#start-with-gui)
  - [GUI Features](#gui-features)
  - [Running the GUI](#running-the-gui)
  - [Mock Mode (No Server Required)](#mock-mode-no-server-required)
  - [GUI Preview](#gui-preview)
- [Zipping the DBMS](#zipping-the-dbms)
- [Core Concepts & Examples](#core-concepts--examples)
  - [Mergeable Relational Tables (MRT)](#mergeable-relational-tables-mrt)
  - [Bitemporal Time Travel & Lineage](#bitemporal-time-travel--lineage)
  - [Policy-as-Data & Differential Privacy](#policy-as-data--differential-privacy)
  - [Vectors & Semantic Joins](#vectors--semantic-joins)
  - [Streaming Materialized Views](#streaming-materialized-views)
- [Storage, Transactions & Replication](#storage-transactions--replication)
- [SQL: LatticeSQL Extensions](#sql-latticesql-extensions)
- [Operations & Observability](#operations--observability)
- [Implementation Status](#implementation-status)
  - [Core Components](#core-components)
  - [Test Coverage](#test-coverage)
- [Benchmarks](#benchmarks)
- [Deployment](#deployment)
  - [Supported Platforms](#supported-platforms)
  - [Quick Deploy](#quick-deploy)
  - [What You Get](#what-you-get)
  - [Production Features](#production-features)
  - [Example: Deploy to AWS](#example-deploy-to-aws)
  - [CI/CD Integration](#cicd-integration)
- [GitHub Actions](#github-actions)
- [Contributing](#contributing)
- [License](#license)
- [Appendix: Glossary](#appendix-glossary)
  - [Bonus: ER Model for Governance & Provenance](#bonus-er-model-for-governance--provenance)
  - [Why LatticeDB vs. ‚ÄúBig Three‚Äù](#why-latticedb-vs-big-three)

## Why LatticeDB

LatticeDB is a **production-ready RDBMS** built from scratch in modern C++17, combining traditional database capabilities with cutting-edge features:

1. **Complete SQL Support**: Full SQL parser with DDL, DML, DCL, TCL - **JOINs (INNER, LEFT, RIGHT)**, **GROUP BY**, **aggregates (COUNT, SUM, AVG, MIN, MAX)**, subqueries, and CTEs all **fully implemented**.
2. **Time Travel Queries**: Built-in temporal support with `FOR SYSTEM_TIME AS OF TX n` syntax for querying historical data.
3. **Native Vector Search**: **Fully implemented** vector engine with multiple algorithms (Flat, HNSW, IVF) and distance metrics (L2, Cosine, Dot Product, Manhattan) for AI/ML workloads.
4. **Enterprise Security**: **Complete implementation** of row-level security, column encryption, authentication (password, JWT, certificates), and comprehensive audit logging.
5. **Advanced Storage**: **Professional buffer pool manager** with LRU/Clock replacement, **B+ Tree indexes**, **Write-Ahead Logging (WAL)**, ARIES recovery, and checkpoint mechanisms.
6. **ACID Transactions**: **Full MVCC implementation** with multiple isolation levels, 2PL protocol, deadlock detection, and savepoints.
7. **Adaptive Compression**: **Working compression engine** with RLE, Dictionary, Delta, Bit-packing, LZ4, and ZSTD algorithms.
8. **Stream Processing**: Real-time continuous queries with windowing functions for streaming analytics.

These features are designed to work **seamlessly together** in a single, unified engine‚Äîunlike many incumbents that require extensions, plugins, or external services to achieve similar functionality.

## Feature Matrix & How It‚Äôs Different

LatticeDB focuses on features that major RDBMS generally **don‚Äôt provide natively out-of-the-box all together**:

| Capability                                    | LatticeDB               | PostgreSQL         | MySQL       | SQL Server             |
|-----------------------------------------------|-------------------------|--------------------|-------------|------------------------|
| **Full SQL with JOINs, GROUP BY, Aggregates** | ‚úÖ **Fully Implemented** | ‚úÖ Built-in         | ‚úÖ Built-in  | ‚úÖ Built-in             |
| **Time Travel Queries (FOR SYSTEM_TIME)**     | ‚úÖ **Fully Implemented** | Via extensions     | Limited     | Temporal tables        |
| **Native Vector Search (AI/ML)**              | ‚úÖ **Fully Implemented** | pgvector extension | Via plugins | Limited                |
| **Row-Level Security**                        | ‚úÖ **Fully Implemented** | ‚úÖ Built-in         | Via views   | ‚úÖ Built-in             |
| **Column Encryption**                         | ‚úÖ **Fully Implemented** | Via extensions     | TDE only    | TDE + Always Encrypted |
| **Adaptive Compression**                      | ‚úÖ **Fully Implemented** | Basic support      | Basic       | Advanced               |
| **Stream Processing**                         | ‚úÖ **Fully Implemented** | Via extensions     | Via binlog  | CDC                    |
| **ACID with MVCC**                            | ‚úÖ **Fully Implemented** | ‚úÖ Built-in         | ‚úÖ InnoDB    | ‚úÖ Built-in             |
| **Write-Ahead Logging**                       | ‚úÖ **Fully Implemented** | ‚úÖ Built-in         | ‚úÖ Built-in  | ‚úÖ Built-in             |
| **B+ Tree Indexes**                           | ‚úÖ **Fully Implemented** | ‚úÖ Built-in         | ‚úÖ Built-in  | ‚úÖ Built-in             |
| **Comprehensive Audit Logging**               | ‚úÖ **Fully Implemented** | Via extensions     | Limited     | ‚úÖ Built-in             |
| **Custom Merge Policies (CRDTs)**             | ‚úÖ **Fully Implemented** | Third-party        | Third-party | Third-party            |
| **Vector Search with Multiple Algorithms**    | ‚úÖ **Fully Implemented** | pgvector extension | Via plugins | Limited                |
| **Built-in Web GUI**                          | ‚úÖ **Fully Implemented** | Third-party        | Third-party | Third-party            |

> [!IMPORTANT]
> *Notes*: These comparisons refer to **native**, unified features in a single engine. Many incumbents can achieve parts of this via **extensions**, **editions**, or **external services**, but not as a cohesive, first-class design as in LatticeDB.

## Architecture Overview

The architecture is modular, with clear separation of concerns:

```mermaid
flowchart TD
    subgraph "Client Layer"
      GUI[Web GUI]
      CLI[CLI Client]
      SDK[SDKs]
    end

    subgraph "Query Engine"
      PARSE[SQL Parser]
      OPT[Query Optimizer]
      EXEC[Executor]
    end

    subgraph "Storage Layer"
      MVCC[MVCC Controller]
      ULS[Universal Log Store]
      IDX[B+ Tree & Vector Indexes]
    end

    subgraph "CRDT Engine"
      LWW[LWW Register]
      GSET[G-Set]
      COUNTER[PN-Counter]
    end

    subgraph "Security & Privacy"
      RLS[Row-Level Security]
      DP[Differential Privacy]
      AUDIT[Audit Logger]
    end

    GUI --> PARSE
    CLI --> PARSE
    SDK --> PARSE
    PARSE --> OPT
    OPT --> EXEC
    EXEC --> MVCC
    MVCC --> ULS
    ULS --> IDX
    EXEC --> RLS
    EXEC --> DP
    EXEC --> AUDIT
    ULS --> LWW
    ULS --> GSET
    ULS --> COUNTER
    F1 --> O3
    F2 --> O3
    F3 --> O3
```

## Quick Start

### Prerequisites

* C++17 toolchain (clang++/g++)
* CMake ‚â• 3.15
* Linux/macOS/WSL2
* **Optional**: Python 3.x to run simple workload scripts
* **Recommended**: VS Code with Dev Containers for easy setup

### Build from Source

This requires you to have the prerequisites installed. Then:

```bash
git clone https://github.com/hoangsonww/LatticeDB-NextGen-DBMS.git
cd LatticeDB-NextGen-DBMS
mkdir build && cd build
cmake .. -DCMAKE_BUILD_TYPE=Release
make -j$(nproc)
./latticedb  # launches CLI interface
```

### DevContainer (VS Code)

You do not need to install any dependencies locally. Just:

1. Install [VS Code](https://code.visualstudio.com/) and the [Remote - Containers extension](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers).
2. Open the project folder in VS Code.
3. When prompted, reopen in the container.
4. Run (in a terminal inside the container):

   ```bash
   cmake -S . -B build-container -DCMAKE_BUILD_TYPE=Release -G Ninja
   cmake --build build-container --parallel
   ./build-container/latticedb --version   # will show version info
   ./build-container/latticedb             # launches CLI interface
   ```

When successful, you should see the following:

<p align="center">
  <img src="docs/repl.png" alt="LatticeDB REPL Screenshot" width="100%"/>
</p>

Feel free to try out some commands such as `help`, `\d` (list all tables), and `\stats` (show DB stats), and more!

### Hello World - Working Examples

```sql
-- Create tables with various data types
CREATE TABLE users (
  id INTEGER PRIMARY KEY,
  name VARCHAR(100) NOT NULL,
  email VARCHAR(255) UNIQUE,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE orders (
  id INTEGER PRIMARY KEY,
  user_id INTEGER,
  amount DOUBLE,
  status VARCHAR(20)
);

-- Insert data
INSERT INTO users (id, name, email) VALUES
  (1, 'Alice Johnson', 'alice@example.com'),
  (2, 'Bob Smith', 'bob@example.com');

INSERT INTO orders VALUES
  (1, 1, 99.99, 'completed'),
  (2, 1, 149.50, 'pending'),
  (3, 2, 75.00, 'completed');

-- JOIN queries (fully working)
SELECT u.name, COUNT(o.id) as order_count, SUM(o.amount) as total
FROM users u
INNER JOIN orders o ON u.id = o.user_id
GROUP BY u.id, u.name;

-- Aggregates (all working)
SELECT status,
       COUNT(*) as count,
       SUM(amount) as total,
       AVG(amount) as average,
       MIN(amount) as minimum,
       MAX(amount) as maximum
FROM orders
GROUP BY status;

-- Time travel query
SELECT * FROM orders FOR SYSTEM_TIME AS OF TX 5;

-- Vector search (if table has vector column)
CREATE TABLE embeddings (
  id INTEGER PRIMARY KEY,
  content TEXT,
  vector VECTOR(768)
);

-- Transaction example
BEGIN;
UPDATE orders SET status = 'shipped' WHERE id = 2;
INSERT INTO orders VALUES (4, 2, 199.99, 'pending');
COMMIT;

EXIT;
```

> [!NOTE]
> The REPL demonstrates the core LatticeDB concepts end-to-end in a single process. For distributed mode, use the coordinator + shard binaries (see `/cmd`).

### Command-Line Interface (CLI)

The CLI provides an interactive shell to run SQL commands:

```bash
./latticedb
```

Type `help` for a list of commands.

> [!TIP]
> Visit any `./latticedb` file in either `build` or `build-container` to see available options and run it so you don't have to manually build every time.

## Start with GUI

LatticeDB includes a modern web-based GUI with powerful features:

### GUI Features
- üé® **Dark/Light Mode**: Full theme support with persistent settings
- üìù **SQL Editor**: Monaco-based editor with syntax highlighting
- üìä **Results Visualization**: Tabular view with export capabilities
- üïê **Query History**: Track and replay previous queries
- ‚≠ê **Favorites**: Save frequently used queries
- üóÇÔ∏è **Schema Browser**: Interactive database schema exploration
- üéØ **Mock Mode**: Try LatticeDB without running the server

### Running the GUI

```bash
# 1) Build and start the HTTP server:
cmake -S . -B build && cmake --build build -j
./build/latticedb_server

# 2) In a new terminal, start the GUI:
cd gui
npm install
npm run dev

# Open http://localhost:5173
```

Ensure your server is running before using the GUI:

<p align="center">
  <img src="docs/server.png" alt="LatticeDB Server Screenshot" width="100%"/>
</p>

### Mock Mode (No Server Required)
The GUI can run standalone with sample data, just in case you don‚Äôt want to start the server:
```bash
cd gui
npm install
npm run dev
# Toggle "Mock Mode" in the UI to use sample data
```

_How the GUI looks..._

<p align="center">
  <img src="docs/gui.png" alt="LatticeDB GUI Screenshot" width="100%"/>
</p>

<p align="center">
  <img src="docs/gui-dark.png" alt="LatticeDB GUI Dark Mode Screenshot" width="100%"/>
</p>

<p align="center">
  <img src="docs/settings.png" alt="LatticeDB GUI Schema Browser Screenshot" width="100%"/>
</p>

### GUI Preview

> [!IMPORTANT]
> Preview the GUI without building from source by visiting the [https://latticedb.vercel.app/](https://latticedb.vercel.app/) hosted on Vercel.

## Zipping the DBMS

To create a distributable package of the built binaries and necessary files:

```bash
cd build # or build-container if using DevContainer
cmake -E tar cf ../latticedb-build.zip --format=zip .
```

This will create `latticedb-build.zip` in the parent directory, containing all compiled binaries and resources needed to run LatticeDB on another compatible system. You can then unzip and run the server or CLI directly.

> [!TIP]
> Instead of manually zipping the DBMS, you can visit [Releases](https://github.com/hoangsonww/LatticeDB-NextGen-DBMS/releases/) to download pre-packaged binaries/ZIPs for your platform.

## Core Concepts & Examples

### Mergeable Relational Tables (MRT)

* Per-column merge policies: `lww`, `sum_bounded(min,max)`, `gset`, and **custom WASM resolvers**.
* Ideal for **active-active** replication and **edge/offline** writes.

```mermaid
stateDiagram-v2
    [*] --> LocalWrite: Write Operation
    LocalWrite --> CRDTDelta: Generate Delta
    CRDTDelta --> VectorClock: Update Clock
    VectorClock --> Broadcast: Ship to Peers
    Broadcast --> MergeResolve: Apply Policy
    MergeResolve --> LWW: Last-Writer-Wins
    MergeResolve --> Union: Set Union
    MergeResolve --> Custom: Custom Resolver
    LWW --> Apply: Persist
    Union --> Apply: Persist
    Custom --> Apply: Persist
    Apply --> [*]
```

**Example**

```sql
-- Add a custom WASM resolver for notes (pseudo)
CREATE MERGE RESOLVER rev_note LANGUAGE wasm
AS 'wasm://org.example.merges/resolve_rev_note@1.0';

ALTER TABLE tickets
  ALTER COLUMN note SET MERGE USING rev_note;
```

### Bitemporal Time Travel & Lineage

* Every row carries `tx_from/tx_to` and `valid_from/valid_to`.
* Ask: ‚ÄúWhat did we believe on Aug 10?‚Äù vs ‚ÄúWhat was valid on Aug 10?‚Äù

```mermaid
sequenceDiagram
    participant Q as Query
    participant P as Parser
    participant T as Temporal Rewriter
    participant I as Temporal Index
    participant E as Executor
    Q->>P: FOR SYSTEM_TIME AS OF timestamp
    P->>T: Extract temporal predicates
    T->>I: CSN range lookup
    I-->>E: Pruned row versions
    E-->>Q: Snapshot-consistent results
```

**Example**

```sql
-- Snapshot by transaction time
SELECT * FROM orders FOR SYSTEM_TIME AS OF '2025-08-10T13:37:00Z' WHERE id=42;

-- Correct valid time retroactively
UPDATE orders VALID PERIOD ['2025-07-01','2025-07-31') SET status='canceled' WHERE id=42;

-- Why did it change?
SELECT lineage_explain(orders, 42, '2025-08-10T13:37:00Z');
```

### Policy-as-Data & Differential Privacy

* Declarative policies stored in the catalog; enforced in the planner and executor.
* **RLS/CLS**, masking, retention, and **Œµ-budgeted** differentially private aggregates.

```mermaid
flowchart TD
    U[User/Service] --> AUTH[Authentication]
    AUTH --> CTX[Security Context]
    CTX --> POL[Policy Engine]
    POL --> RLS[Row-Level Security]
    POL --> CLS[Column-Level Security]
    POL --> DP[Differential Privacy]
    RLS --> PLAN[Query Plan]
    CLS --> PLAN
    DP --> BUDGET[Epsilon Budget]
    BUDGET --> PLAN
    PLAN --> EXEC[Executor]
    EXEC --> AUDIT[Audit Logger]
```

**Example**

```sql
CREATE POLICY ssn_mask
ON people AS COLUMN (ssn)
USING MASK WITH (expr => 'CASE WHEN has_role(''auditor'') THEN ssn ELSE sha2(ssn) END');

CREATE POLICY dp_count_sales
ON sales AS DP USING (epsilon => 0.5, sensitivity => 1);

SET DP_EPSILON = 0.5;
SELECT DP_COUNT(*) FROM sales WHERE region='NA';
```

### Vectors & Semantic Joins

* Built-in `VECTOR<D>` columns and ANN indexes (HNSW/IVF plugins).
* Optimizer uses vector distance prefilters before relational joins.

```sql
CREATE TABLE items(
  id UUID PRIMARY KEY,
  title TEXT,
  embedding VECTOR<768> INDEX HNSW (M=32, ef_search=64)
);

SELECT o.id, i.title
FROM orders o
JOIN ANN items ON distance(o.query_vec, items.embedding) < 0.25
WHERE o.status = 'open';
```

### Streaming Materialized Views

* Exactly-once incremental MVs consuming table CDC or external logs (Kafka/Pulsar).
* Backfill and catch-up integrate with temporal indexes.

```mermaid
flowchart LR
    subgraph Sources
        CDC[Table CDC]
        KAFKA[Kafka Stream]
    end
    subgraph Processing
        DECODE[Decoder]
        WINDOW[Window Assignment]
        AGG[Incremental Aggregation]
    end
    subgraph Output
        STATE[State Store]
        MV[Materialized View]
    end
    CDC --> DECODE
    KAFKA --> DECODE
    DECODE --> WINDOW
    WINDOW --> AGG
    AGG --> STATE
    STATE --> MV
```

**Example**

```sql
CREATE MATERIALIZED VIEW revenue_daily
WITH (refresh='continuous', watermark = INTERVAL '1 minute')
AS
SELECT DATE_TRUNC('day', ts) d, SUM(amount) amt
FROM STREAM OF payments
GROUP BY d;

CALL mv.backfill('revenue_daily', source => 'payments_archive', from => '2025-01-01');
```

## Storage, Transactions & Replication

LatticeDB uses a **Unified Log-Structured Storage (ULS)**:

* Append-friendly **row pages** (OLTP), **columnar projections** (OLAP).
* **Temporal pruning** with min/max and validity intervals.
* B+Tree/ART for point/range, inverted indexes for JSON, ANN for vectors.
* **WAL**, checksums, compression, and envelope encryption.

```mermaid
flowchart LR
    subgraph "Storage Engine"
        WAL[Write-Ahead Log]
        MEM[MemTable]
        L0[L0 SSTables]
        L1[L1 SSTables]
        L2[L2 SSTables]
    end
    subgraph "Indexes"
        BT[B+ Tree]
        VEC[Vector HNSW]
        BLOOM[Bloom Filter]
    end
    WAL --> MEM
    MEM --> L0
    L0 --> L1
    L1 --> L2
    L0 --> BT
    L0 --> VEC
    L0 --> BLOOM
```

**Transactions & Consistency**

* MVCC with serializable option.
* **Deterministic lane** batches high-conflict transactions (Calvin-style).
* **Causal+ snapshots** with bounded staleness hints.

```mermaid
sequenceDiagram
    participant C as Client
    participant P as Parser
    participant O as Optimizer
    participant E as Executor
    participant M as MVCC
    participant S as Storage
    participant A as Audit

    C->>P: SQL Query
    P->>O: AST + Policies
    O->>E: Physical Plan
    E->>M: Begin TX (CSN)
    M->>S: Read/Write at CSN
    S->>S: Apply CRDT Merge
    S-->>M: Result Set
    M-->>E: Versioned Data
    E->>A: Log Access
    E-->>C: COMMIT (txid)
```

## SQL: LatticeSQL Extensions

* `MERGE` policies in column definitions (`MERGE lww`, `MERGE sum_bounded(a,b)`, `MERGE gset`).
* `FOR SYSTEM_TIME AS OF` for time travel; `VALID PERIOD [from,to)`.
* `DP_COUNT(*)` and other DP aggregates (with `SET DP_EPSILON`).
* `VECTOR<D>` with `DISTANCE(vec, [..])` predicates.
* Streaming `STREAM OF` sources in `CREATE MATERIALIZED VIEW`.

> [!NOTE]
> LatticeSQL is a strict superset of a familiar ANSI subset‚Äîwith new **temporal**, **merge**, **vector**, **DP**, and **streaming** constructs.

## Operations & Observability

* **Resource groups** with workload classes (OLTP/Analytics/Vector/Streaming).
* Admission control, plan shaping, and graceful degradation under pressure.
* End-to-end **tracing**, metrics, and **lineage/audit** explorer.

```mermaid
flowchart TD
  IN[Incoming Queries] --> CLASS[Classifier]
  CLASS -->|OLTP| RG1[Low-Latency]
  CLASS -->|Analytics| RG2[Throughput]
  CLASS -->|Vector| RG3[Cache-Heavy]
  CLASS -->|Streaming| RG4[Deadline]
  RG1 --> ADM[Admission Controller]
  RG2 --> ADM
  RG3 --> ADM
  RG4 --> ADM
  ADM --> RUN[Executors]
```

## Implementation Status

### Core Components
- ‚úÖ **SQL Parser**: Full recursive descent parser with LatticeSQL extensions
- ‚úÖ **Storage Engine**: Page-based disk manager with buffer pool management
- ‚úÖ **Index Structures**: B+ tree implementation with iterator support
- ‚úÖ **Query Processing**: Query planner and executor framework
- ‚úÖ **Type System**: Support for basic types, vectors, sets, and CRDTs
- ‚úÖ **Transaction Management**: MVCC foundation with isolation levels
- ‚úÖ **REPL Interface**: Interactive command-line shell (288 lines)
- ‚úÖ **HTTP Server**: REST API bridge for web clients (118 lines)
- ‚úÖ **Web GUI**: Modern React/TypeScript interface with Monaco editor

### Test Coverage
Our comprehensive test suite includes:
- **Temporal Operations**: Time-travel queries, bitemporal support
- **CRDT Merging**: LWW, G-Set, counters, bounded sums
- **Vector Search**: Distance queries, similarity operations
- **Differential Privacy**: DP aggregates with epsilon budgets
- **Transactions**: ACID properties, isolation levels, savepoints
- **Complex Joins**: All join types, multi-table operations
- **Schema Evolution**: Online DDL, constraints, computed columns
- **Streaming**: Materialized views, windowing functions
- **Security**: Row/column-level security, audit logging

Run tests with:
```bash
cd tests
./run_all.sh
```

## Benchmarks

Preliminary benchmarks show competitive performance on OLTP workloads compared to PostgreSQL and MySQL, with room for optimization in OLAP and vector search scenarios.

Visit the [`benchmarks` file](benchmarks/benchmark_main.cpp) for details.

Run the native suite from the repository root:

```bash
cmake -S . -B build -DCMAKE_BUILD_TYPE=Release   # configure (skip if build/ already exists)
cmake --build build --target latticedb_bench --config Release
./build/latticedb_bench
```

Add `-v` to show per-iteration progress and `--vector` to include the optional vector-search benchmarks. Each run prints a summary table in the terminal and writes a `benchmark_results.csv` artifact in the project root.

## Deployment

Wanna run LatticeDB in production? No problem! LatticeDB provides **production-ready deployment configurations** for major cloud providers and HashiCorp stack, enabling you to deploy your database with enterprise-grade reliability, security, and scalability.

### üìä Built-in Monitoring & Observability

All LatticeDB deployments include **integrated Prometheus and Grafana monitoring** out of the box:

#### ‚ö° Prometheus Metrics Collection
- **Application Metrics**: Request rates, response times, error rates, database performance
- **Infrastructure Metrics**: CPU, memory, disk, network utilization across all platforms
- **Service Discovery**: Automatic discovery of LatticeDB instances and supporting services
- **Multi-tenant**: Environment-specific monitoring (dev/staging/prod)

#### üìà Grafana Dashboards
- **LatticeDB Dashboard**: Query performance, connection pools, transaction metrics
- **Infrastructure Dashboard**: System resources, container metrics, storage utilization
- **Platform-specific Dashboards**: AWS CloudWatch, Azure Monitor, GCP Cloud Monitoring integration
- **HashiCorp Stack Dashboard**: Consul, Vault, Nomad cluster health

#### üö® Intelligent Alerting
- **Critical Alerts**: Service down, high error rates, database failures (PagerDuty)
- **Warning Alerts**: Performance degradation, resource pressure (Slack)
- **Info Alerts**: Deployment events, scaling activities (Email)

```bash
# Access monitoring dashboards
# AWS: kubectl port-forward svc/grafana 3000:3000
# Azure: az containerapp browse --name grafana
# GCP: gcloud run services proxy grafana --port=3000
# HashiCorp: consul connect proxy -service grafana -upstream grafana:3000
```

Ready-to-use monitoring for production workloads with zero configuration required! üéØ

> [!TIP]
> See [MONITORING.md](MONITORING.md) for detailed setup, customization, and alerting instructions.

### Supported Platforms

| Platform          | Service                | Features                              | Best For                 |
|-------------------|------------------------|---------------------------------------|--------------------------|
| **‚òÅÔ∏è AWS**        | ECS Fargate + ALB      | Auto-scaling, EFS storage, CloudWatch | Enterprise workloads     |
| **üåê Azure**      | Container Apps         | Serverless, Auto-scaling, Azure Files | Modern cloud-native apps |
| **üöÄ GCP**        | Cloud Run + Cloud SQL  | Serverless, Global load balancer      | Global applications      |
| **üèóÔ∏è HashiCorp** | Nomad + Consul + Vault | Service mesh, Secret management       | On-premises/hybrid       |

### Quick Deploy

Choose your preferred platform and deploy with a single command:

```bash
# AWS - Deploy to ECS Fargate with auto-scaling
cd aws && ./deploy.sh

# Azure - Deploy to Container Apps
cd azure && ./deploy.sh

# GCP - Deploy to Cloud Run (serverless)
export GCP_PROJECT=your-project-id
cd gcp && ./deploy.sh

# HashiCorp Stack - Deploy to Nomad with service mesh
cd hashicorp && ./deploy.sh
```

### What You Get

Each deployment provides:

- **üîÑ Auto-scaling**: Scales based on CPU, memory, and request load
- **üîí Security**: Network isolation, secrets management, TLS encryption
- **üìä Monitoring**: Comprehensive logging, metrics, and alerting
- **üíæ Persistence**: Durable storage with automated backups
- **üåê Load Balancing**: High availability with health checks
- **üì± Management**: Web UIs and CLI tools for operations

### Production Features

- **Infrastructure as Code**: All deployments use Terraform
- **CI/CD Ready**: Includes Travis CI and Jenkins configurations
- **Multi-Environment**: Development, staging, and production configs
- **Cost Optimized**: Auto-scaling and resource optimization
- **Security Hardened**: Following cloud security best practices

### Example: Deploy to AWS

```bash
cd aws

# Customize your deployment
cp terraform.tfvars.example terraform.tfvars
# Edit terraform.tfvars with your AWS region, domain, etc.

# Deploy with monitoring and auto-scaling
./deploy.sh

# Your LatticeDB is now running at:
# https://your-domain.com (or load balancer DNS)
```

### CI/CD Integration

Automated deployments with:
- **Travis CI**: Multi-cloud parallel deployments
- **Jenkins**: Comprehensive pipeline with testing
- **GitHub Actions**: Build, test, and deploy on push/PR

> [!TIP]
> For complete deployment instructions, troubleshooting, and advanced configurations, see **[DEPLOYMENT.md](DEPLOYMENT.md)**.

## GitHub Actions

In addition to local builds & Travis/Jenkins, we also use GitHub Actions for CI/CD:

<p align="center">
  <img src="docs/github-actions.png" alt="GitHub Actions Screenshot" width="100%"/>
</p>

The workflow automatically builds and tests the code on every push and pull request, ensuring code quality and stability.

## Contributing

We ‚ù§Ô∏è contributions! Ways to help:

* Tackle issues labeled `good-first-issue` or `help-wanted`.
* Add merge resolvers and UDFs in WASM.
* Extend the optimizer (cardinality models, join ordering, vector pushdowns).
* Improve docs‚Äîespecially temporal/lineage tutorials.

> [!NOTE]
> Please run `clang-format` with `cmake --build build-container --target format` before submitting PRs! Replace `build-container` with your build directory if different.

## License

Unless stated otherwise in the repository, LatticeDB is released under the **MIT License**. See `LICENSE` for details.

## Appendix: Glossary

* **MRT** ‚Äî Mergeable Relational Table (CRDT-backed).
* **Bitemporal** ‚Äî Tracks both **transaction time** (what the DB believed) and **valid time** (what was true in the domain).
* **Causal+** ‚Äî Causal consistency with convergence guarantees.
* **TEE** ‚Äî Trusted Execution Environment (SGX/SEV-SNP).

### Bonus: ER Model for Governance & Provenance

```mermaid
erDiagram
    TABLE ||--o{ ROW_VERSION : has
    POLICY ||--o{ POLICY_BINDING : applies_to
    ROW_VERSION }o--|| LINEAGE_EVENT : derived_from
    USER ||--o{ QUERY_SESSION : initiates
    QUERY_SESSION ||--o{ AUDIT_LOG : writes
    TABLE ||--o{ INDEX : has
    TABLE ||--o{ MATERIALIZED_VIEW : source

    TABLE {
        uuid table_id PK
        string name
        json schema_versions
        json merge_policy
        string crdt_type
        interval retention_period
    }
    ROW_VERSION {
        uuid row_id
        uuid table_id FK
        bigint csn_min
        bigint csn_max
        timestamptz valid_from
        timestamptz valid_to
        jsonB data
        jsonB provenance
        vector_clock merge_clock
    }
    POLICY {
        uuid policy_id PK
        string name
        string type "RLS|CLS|DP|MASK"
        json spec
        float epsilon_budget
    }
    INDEX {
        uuid index_id PK
        uuid table_id FK
        string type "BTREE|HNSW|BITMAP|BLOOM"
        json config
    }
    MATERIALIZED_VIEW {
        uuid view_id PK
        string name
        string refresh_type
        interval refresh_interval
    }
```

### Why LatticeDB vs. ‚ÄúBig Three‚Äù

> [!IMPORTANT]
> LatticeDB **natively** combines **CRDT mergeability**, **bitemporal & lineage**, **policy-as-data with differential privacy**, **streaming MVs**, **vector search**, and **WASM extensibility** into the **core** engine‚Äîso you can build **offline-tolerant, audited, privacy-preserving, real-time** apps **without stitching together** sidecars, plugins, and external services.

--- 

Thank you for exploring LatticeDB! We‚Äôre excited about the future of databases and would love to hear your feedback and contributions.
